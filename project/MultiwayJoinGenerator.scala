object MultiwayJoinGenerator {
  case class Joined(code: String)
  case class IncompleteJoin(code: String)
  case class Binding(code: String)
  case class Binder(code: String)
  case class Lift(methodSignature: String, memoryImpl: String, scaldingImpl: String)
  case class JoinPermutation(binding: Binding, binder: Binder, lift: Lift)

  case class GeneratedJoinLevel(
    joined:           Joined,
    nextIncomplete:   Option[IncompleteJoin],
    joinPermutations: List[JoinPermutation]
  )

  def generateJoinCode(supportedDepth: Int): List[GeneratedJoinLevel] = {
    2.to(supportedDepth).foldRight(List[GeneratedJoinLevel]())((level, generated) => {

      val joined = Joined(genJoined(level, supportedDepth))
      val incompleteJoin = genIncompleteJoin(level, supportedDepth).map(IncompleteJoin(_))

      val joinPermutations = permute(joinTypes, level - 1).map(permutation => {

        val binding = Binding(genBinding(level, permutation))
        val binder = Binder(genBinder(level, permutation))
        val lift = genLiftMethodSig(level, permutation, "P")
        val liftMemory = genLiftMemory(level, permutation)
        val liftScalding = genLiftScalding(level, permutation)

        JoinPermutation(binding, binder, Lift(lift, liftMemory, liftScalding))

      })
      GeneratedJoinLevel(joined, incompleteJoin, joinPermutations) :: generated
    })
  }

  // 1234...
  def numbersTo(level: Int): String = 1.to(level).mkString

  // S123...
  def sourceTypeParam(level: Int): String = "S" + numbersTo(level)

  // S1, S2, S3, ...
  def sourceTypeParamsList(level: Int): List[String] = 1.to(level).map(l => s"S$l").toList

  // S12, S123, S1234, ...
  def joinedSourceParamsList(supportedDepth: Int, level: Int = 2): List[String] =
    level.to(supportedDepth).foldRight(List[String]())((l, acc) => s"S${numbersTo(l)}" :: acc)

  // J1, J2, J3, ...
  def joinTypeParamsList(level: Int) = 1.to(level - 1).map(l => s"J$l")

  // (Inner, Inner, Inner), (Inner, Inner, Outer), (Inner, Outer, Inner), (Inner, Outer, Outer), ...
  def permute[T](values: List[T], level: Int, acc: List[T] = Nil): List[List[T]] =
    if (level == 0) List(acc)
    else values.flatMap(v => permute(values, level - 1, v :: acc))

  case class NameType(name: String, typ: String)

  sealed abstract class JoinType(val camelName: String)
  case object Inner extends JoinType("Inner")
  case object Left  extends JoinType("Left")
//  case object Right extends JoinType("Right")

  def joinTypes = List[JoinType](Inner, Left/*, Right*/)

  def joinFunctions(level: Int, start: Int = 2): List[NameType] =
    start.to(level).foldRight(List[NameType]())((l, nameTypes) => {
      //                   eg, s123j3                        eg,  S123 => J3
      val soFar = NameType(s"s${numbersTo(l - 1)}j${l - 1}", s"S${numbersTo(l - 1)} => J${l - 1}")
      //                  eg, s4j3           eg, S4 => J3
      val next = NameType(s"s${l}j${l - 1}", s"S${l} => J${l - 1}")
      soFar :: next :: nameTypes
    })

  // (S1, Option[S2]), (S1, Option[S2], S3), (S1, Option[S2], S3, S4), ...
  def joinedSourceTypes(level: Int, permutation: List[JoinType], start: Int = 2): String =
    start.to(level).foldRight(List[List[String]]())((l, acc) =>
      ("S1" :: permutation.zipWithIndex.take(l - 1).map {
        case (Inner, idx) => s"S${idx + 2}"
        case (Left, idx) => s"Option[S${idx + 2}]"
      }) :: acc
    ).map(_.mkString("(", ", ", ")")).mkString(", ")


  val prelude =
    """/*
    | * Generated file, do not modify.
    | *
    | * File generated by https://github.com/CommBank/coppersmith/project/MultiwayJoinGenerator.scala
    | */
    |""".stripMargin

  def generateJoined(joins: List[GeneratedJoinLevel]): String = {
    val content = joins.map(join =>
      join.joined.code + "\n" + join.nextIncomplete.map(_.code).getOrElse("")
    ).mkString("\n\n")
    prelude + s"""
      |package commbank.coppersmith.generated
      |
      |import commbank.coppersmith.FeatureSource
      |
      |${content}
      |""".stripMargin
  }

  def genJoined(level: Int, supportedDepth: Int): String = {
    val srcTypeParams = sourceTypeParamsList(level).mkString(", ")
    val srcTypeParam = sourceTypeParam(level)
    val nextSrcTypeParams = sourceTypeParamsList(level + 1).mkString(", ")
    val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
    val joinTypeParams = joinTypeParamsList(level).mkString(", ")
    val joinedSrcParams = joinedSourceParamsList(level).mkString(", ")
    val joinFunctionsAndTypes = joinFunctions(level).map(jf =>
      jf.name + ": " + jf.typ
    ).mkString(",\n  ")

    s"""case class Joined${level}[
      |  ${srcTypeParams},
      |  ${joinOrderingTypeParams},
      |  ${joinedSrcParams}
      |](
      |  ${joinFunctionsAndTypes},
      |  filter: Option[${srcTypeParam} => Boolean]
      |) extends FeatureSource[${srcTypeParam}, Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}]](filter) {
      |
      |  type FS = Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}]
      |
      |  def copyWithFilter(filter: Option[${srcTypeParam} => Boolean]) = copy(filter = filter)""".stripMargin +
      {
        if (level < supportedDepth) { s"""
      |
      |  def innerJoinTo[S${level + 1}] =
      |    IncompleteJoin${level + 1}[
      |      ${nextSrcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}, (${srcTypeParam}, S${level + 1})
      |    ](${joinFunctions(level).map(_.name).mkString(", ")})
      |  def leftJoinTo[S${level + 1}] =
      |    IncompleteJoin${level + 1}[
      |      ${nextSrcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}, (${srcTypeParam}, Option[S${level + 1}])
      |    ](${joinFunctions(level).map(_.name).mkString(", ")})""".stripMargin
        } else ""
      } + """
      |}
      |""".stripMargin
  }

  def genIncompleteJoin(level: Int, supportedDepth: Int): Option[String] = {
    if (level < supportedDepth) {
      val nextSrcTypeParams = sourceTypeParamsList(level + 1).mkString(", ")
      val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
      val nextJoinTypeParams = joinTypeParamsList(level + 1).mkString(", ")
      val joinedSrcParams = joinedSourceParamsList(level).mkString(", ")
      val joinFunctionsAndTypes = joinFunctions(level).map(jf =>
        jf.name + ": " + jf.typ
      ).mkString(",\n  ")
      val nextJoinFunctionsAndTypes = joinFunctions(level + 1, level + 1).map(jf =>
        jf.name + ": " + jf.typ
      ).mkString(",\n    ")

      Some(
        s"""case class IncompleteJoin${level + 1}[${nextSrcTypeParams}, ${joinOrderingTypeParams}, ${joinedSrcParams}, ${sourceTypeParam(level + 1)}](
        |  ${joinFunctionsAndTypes}
        |) {
        |  def on[J${level} : Ordering](
        |    ${nextJoinFunctionsAndTypes}
        |  ): Joined${level + 1}[${nextSrcTypeParams}, ${nextJoinTypeParams}, ${joinedSourceParamsList(level + 1).mkString(", ")}] =
        |    Joined${level + 1}(${joinFunctions(level + 1).map(_.name).mkString(", ")}, None)
        |}""".stripMargin
      )
    } else None
  }

  def generateBindings(joins: List[GeneratedJoinLevel]): String = {
    val content = joins.map(
      _.joinPermutations.map(_.binding.code).mkString("\n")
    ).mkString("\n\n")
    prelude + s"""
      |package commbank.coppersmith.generated
      |
      |import commbank.coppersmith.{DataSource, Lift}
      |
      |trait GeneratedBindings {
      |${content}
      |}
      |""".stripMargin
  }

  def genBinding(level: Int, permutation: List[JoinType]): String = {
    val joinType = permutation.map(_.camelName).mkString
    val srcTypeParams = sourceTypeParamsList(level).mkString(", ")
    val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
    val joinTypeParams = joinTypeParamsList(level).mkString(", ")
    val sources = 1.to(level).map(l => s"s${l}: DataSource[S${l}, P]").mkString(",\n    ")
    val sourceNames = 1.to(level).map(l => s"s${l}").mkString(", ")

    s"""  def join${joinType}[${srcTypeParams}, ${joinOrderingTypeParams}, P[_] : Lift](
      |    ${sources}
      |  ) = Joined${level}${joinType}Binder[${srcTypeParams}, ${joinTypeParams}, P](${sourceNames})""".stripMargin
  }

  def generateBinders(joins: List[GeneratedJoinLevel]): String = {
    val content = joins.map(
      _.joinPermutations.map(_.binder.code).mkString("\n")
    ).mkString("\n\n")
    prelude + s"""
      |package commbank.coppersmith.generated
      |
      |import commbank.coppersmith.{DataSource, SourceBinder, Lift}
      |
      |${content}
      |""".stripMargin
  }

  def genBinder(level: Int, permutation: List[JoinType]): String = {
    val joinType = permutation.map(_.camelName).mkString
    val srcTypeParams = sourceTypeParamsList(level).mkString(", ")
    val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
    val joinTypeParams = joinTypeParamsList(level).mkString(", ")
    val joinedSrcTypes = joinedSourceTypes(level, permutation)
    val joinedReturnType = joinedSourceTypes(level, permutation, level)
    val sources = 1.to(level).map(l => s"s${l}: DataSource[S${l}, P]").mkString(",\n  ")
    val loadCalls = 1.to(level).map(l => s"s${l}.load").mkString(", ")

    s"""
      |case class Joined${level}${joinType}Binder[${srcTypeParams}, ${joinOrderingTypeParams}, P[_] : Lift](
      |  ${sources}
      |) extends SourceBinder[${joinedReturnType}, Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcTypes}], P] {
      |  def bind(j: Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcTypes}]): P[${joinedReturnType}] = {
      |    implicitly[Lift[P]].liftJoin${joinType}(j)(${loadCalls})
      |  }
      |}
      """.stripMargin.trim
  }

  def generateLift(joins: List[GeneratedJoinLevel]): String = {
    val content = joins.map(
      _.joinPermutations.map(_.lift.methodSignature).mkString("\n")
    ).mkString("\n\n")

    prelude + s"""
      |package commbank.coppersmith.generated
      |
      |trait GeneratedLift[P[_]] {
      |${content}
      |}
      |""".stripMargin
  }

  def genLiftMethodSig(level: Int, permutation: List[JoinType], pType: String): String = {
    val joinType = permutation.map(_.camelName).mkString
    val srcTypeParams = sourceTypeParamsList(level).mkString(", ")
    val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
    val joinTypeParams = joinTypeParamsList(level).mkString(", ")
    val joinedSrcTypes = joinedSourceTypes(level, permutation)
    val joinedReturnType = joinedSourceTypes(level, permutation, level)
    val sources = 1.to(level).map(l => s"s${l}: ${pType}[S${l}]").mkString(", ")

    s"""  def liftJoin${joinType}[${srcTypeParams}, ${joinOrderingTypeParams}](
    |    joined: Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcTypes}]
    |  )(${sources}): ${pType}[${joinedReturnType}]""".stripMargin
  }

  def generateLiftScalding(joins: List[GeneratedJoinLevel]): String = {
    val content = joins.map(
      _.joinPermutations.map(_.lift.scaldingImpl).mkString("\n")
    ).mkString("\n\n")

    prelude + s"""
      |package commbank.coppersmith.scalding.generated
      |
      |import com.twitter.scalding.TypedPipe
      |
      |import commbank.coppersmith.generated._
      |
      |trait GeneratedScaldingLift {
      |${content}
      |}
      |""".stripMargin
  }

  def genLiftScalding(level: Int, permutation: List[JoinType]): String = {
    genLiftMethodSig(level, permutation, "TypedPipe") + " = {\n" +
      permutation.zipWithIndex.foldRight(List[String]()){ case ((jt, idx), joins) => {
        val level = idx + 1
        val joinType = jt match {
          case Inner => "join"
          case Left => "leftJoin"
        }
        val joinSrc = s"s${numbersTo(level)}"
        val nextSrc = s"s${level + 1}"
        val join = s"j${level}"

        val init = if (level == 1) "    s1" else "  "

        val group = s".groupBy(joined.${joinSrc}${join}).${joinType}(${nextSrc}.groupBy(joined.${nextSrc}${join})).values"

        val map = if (level == 1) "" else {
          val sources = 1.to(level).map(l => s"s$l").mkString(", ")
          s"\n      .map { case ((${sources}), s${level + 1}) => (${sources}, s${level + 1}) }"
        }

        (init + group + map) :: joins
      }}.mkString("", "\n    ", "\n  }")
  }

  def generateLiftMemory(joins: List[GeneratedJoinLevel]): String = {
    val content = joins.map(
      _.joinPermutations.map(_.lift.memoryImpl).mkString("\n")
    ).mkString("\n\n")

    prelude + s"""
      |package commbank.coppersmith.lift.generated
      |
      |import commbank.coppersmith.generated._
      |import commbank.coppersmith.lift.MemoryLift.{innerJoin, leftJoin}
      |
      |trait GeneratedMemoryLift {
      |${content}
      |}
      |""".stripMargin
  }

  def genLiftMemory(level: Int, permutation: List[JoinType]): String = {
    genLiftMethodSig(level, permutation, "List") + " = {\n" +
      permutation.zipWithIndex.foldRight(List[String]()){ case ((permutation, idx), joins) => {
        val level = idx + 1

        val joinType = permutation match {
          case Inner => "innerJoin"
          case Left => "leftJoin"
        }
        val joinSrc = s"s${numbersTo(level)}"
        val nextSrc = s"s${level + 1}"
        val join = s"j${level}"

        val group = s"    val s${numbersTo(level + 1)} = ${joinType}(joined.${joinSrc}${join}, joined.${nextSrc}${join}, ${joinSrc}, ${nextSrc})"

        val map = if (level == 1) "" else {
          val sources = 1.to(level).map(l => s"s$l").mkString(", ")
          s"\n      .map { case ((${sources}), s${level + 1}) => (${sources}, s${level + 1}) }"
        }

        (group + map) :: joins
      }}.mkString("", "\n    ", s"\n    s${numbersTo(level)}\n  }")
  }
}
